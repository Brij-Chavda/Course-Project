# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kJaOif9_1nDWqdLgMNgRSJPk_Sogs2-h
"""

"""Final_code:"""

#nltk load:
import nltk
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('wordnet')
nltk.download('averaged_perceptron_tagger')

#data preprocessing
def preprocess(filename_train,filename_test):
  from nltk.tokenize import sent_tokenize, word_tokenize
  from nltk.stem import PorterStemmer
  from nltk.tokenize import RegexpTokenizer
  from nltk.stem import WordNetLemmatizer 
  from nltk.corpus import wordnet
  from nltk.corpus import stopwords 
  from nltk.tokenize import word_tokenize
  import json 
  lemmatizer = WordNetLemmatizer() 
  porter = PorterStemmer()
  def lemma(sentence):
    lemma_sen = []
    word_list = nltk.word_tokenize(sentence)
    lemma_sen = ' '.join([lemmatizer.lemmatize(w.lower(),pos='v') for w in word_list])
    return lemma_sen
  def stemSentence(sentence):
    stem_sentence=[]
    token_words=word_tokenize(str(sentence))
    for word in token_words:
      stem_sentence.append(porter.stem(word))
      stem_sentence.append(" ")
    return stem_sentence
  def rmpunctuation(sentence):
    senapp = []
    for i in sentence:
      tokenizer = RegexpTokenizer(r'\w+')
      rmsentence = tokenizer.tokenize(str(i))
      senapp.append(" ".join(rmsentence))
    return senapp
  def rmstwords(sentence):   
    stop_words = set(stopwords.words('english'))
    word_tokens = word_tokenize(sentence.lower())
    fil_sen = [w for w in word_tokens if not w in stop_words]
    return fil_sen
  def dataset(filename):
    data = [json.loads(line) for line in open(filename, 'r')]
    labels = []
    sentence1 = []
    sentence2 = []
    count = 0
    for i in data:
      if i['gold_label'] != '-':
        sentence1.append(i['sentence1'])
        sentence2.append(i['sentence2'])
        labels.append(i['gold_label'])      
    sentence1 = np.array(sentence1)
    sentence2 = np.array(sentence2)
    labels = np.array(labels)
    s1_rmst = [rmstwords(str(i)) for i in sentence1]
    s1_lemma = [lemma(str(i)) for i in s1_rmst]
    s1_final = rmpunctuation(s1_lemma)
    s2_rmst = [rmstwords(str(i)) for i in sentence2]
    s2_stem = [lemma(str(i)) for i in s2_rmst]
    s2_final = rmpunctuation(s2_stem) 
    return s1_final,s2_final,labels
  sen1_train,sen2_train,Ytrain = dataset(filename_train)
  sen1_test,sen2_test,Ytest = dataset(filename_test)
  #print(labels)
  from sklearn.preprocessing import LabelEncoder
  import tensorflow as tf
  encoder = LabelEncoder()
  encoder.fit(Ytrain)
  encoded_Y = encoder.transform(Ytrain)
  Ytrain_encode = tf.keras.utils.to_categorical(encoded_Y)
  encoded_Y = encoder.transform(Ytest)
  Ytest_encode = tf.keras.utils.to_categorical(encoded_Y)
  return sen1_train,sen2_train,Ytrain_encode,sen1_test,sen2_test,Ytest_encode

import numpy as np
import json
import pandas as pd
import pickle
from numpy import array
from numpy import asarray
from numpy import zeros
from tensorflow import keras
import tensorflow as tf
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Embedding
from tensorflow.keras.layers import Input
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Embedding
from tensorflow.keras.layers import Input
from tensorflow.keras.layers import LSTM
from tensorflow.keras.layers import Bidirectional
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Masking
from tensorflow.keras.layers import GlobalAveragePooling1D
from tensorflow.keras.layers import GlobalMaxPooling1D
from tensorflow.keras.layers import Attention

#tokenize and word embedding
def embedding(sen1_train,sen2_train,sen1_test,sen2_test):
  
  t = Tokenizer()
  t.fit_on_texts(sen1_train)
  t.fit_on_texts(sen2_train)
  vocab_size = len(t.word_index) + 1
  vocab_size1 = len(t.word_index) + 1
  encoded_docs = t.texts_to_sequences(sen1_train)
  encoded_docs1 = t.texts_to_sequences(sen2_train)
  max_length = 78
  padded_docs = pad_sequences(encoded_docs, maxlen=max_length, padding='post')
  padded_docs1 = pad_sequences(encoded_docs1, maxlen=max_length, padding='post')
  p1 = np.array(padded_docs)
  p2 = np.array(padded_docs1)
  import pickle
  with open('embedding.pickle', 'rb') as handle:
    embedding_matrix = pickle.load(handle)
  encoded_docst = t.texts_to_sequences(sen1_test)
  encoded_docst1 = t.texts_to_sequences(sen2_test)
  padded_docst = pad_sequences(encoded_docst, maxlen=max_length, padding='post')
  padded_docst1 = pad_sequences(encoded_docst1, maxlen=max_length, padding='post')
  pt1 = np.array(padded_docst)
  pt2 = np.array(padded_docst1)
  return p1,p2,pt1,pt2,vocab_size,embedding_matrix

#model
def create_model(vocab_size,embedding_matrix): 

  input1 =Input(shape = (78))
  e1 = Embedding(vocab_size, 300, weights=[embedding_matrix], input_length=78, trainable=False)(input1)
  #mask1 = Masking(mask_value=0)(e1)
  LSTM_IP_layer1,h1,m1,h2,m2 = Bidirectional(LSTM(300, input_shape=(78,300), return_sequences=True, return_state=True, dropout = 0.25))(e1)
  hstate1 = tf.keras.layers.Concatenate(axis = 1)([h1,h2])

  def Func3(X):
      return X
  
  LSTM_IP_layer1 = tf.keras.layers.Lambda(Func3, name = 'LSTM_IP_layer1')(LSTM_IP_layer1)
  encoding1 = Attention()([LSTM_IP_layer1, hstate1])
  en1 = GlobalAveragePooling1D()(encoding1)
  lstm1 = GlobalMaxPooling1D()(LSTM_IP_layer1)
  lstm1avg = GlobalAveragePooling1D()(LSTM_IP_layer1)
  enmax1 = GlobalMaxPooling1D()(encoding1)
  OP1 = tf.keras.layers.Concatenate()([lstm1,en1])
  
  input2 = Input(shape = (78))
  e2 = Embedding(vocab_size, 300, weights=[embedding_matrix], input_length=78, trainable=False)(input2)
  #mask2 = Masking(mask_value=0.0)(e2)
  LSTM_IP_layer2,h3,m3,h4,m4 = Bidirectional(LSTM(300, input_shape=(78,300),  return_sequences=True, return_state=True, dropout = 0.25))(e2)
  hstate2 = tf.keras.layers.Concatenate(axis = 1)([h3,h4])

  LSTM_IP_layer2 = tf.keras.layers.Lambda(Func3, name = 'LSTM_IP_layer2')(LSTM_IP_layer2)
  encoding2 = Attention()([LSTM_IP_layer2, hstate2])
  en2 = GlobalAveragePooling1D()(encoding2)
  enmax2 = GlobalMaxPooling1D()(encoding2)
  lstm2 = GlobalMaxPooling1D()(LSTM_IP_layer2)
  lstm2avg = GlobalAveragePooling1D()(LSTM_IP_layer2)
  OP2 = tf.keras.layers.Concatenate()([lstm2,en2])
  #max2 = tf.nn.max_pool()(LSTM_IP_layer2)

  def Func2(x):
      return tf.keras.backend.reverse(x,axes=1)

  def Func(x):
      return (x[0]*x[1])
  Lambda_1 = tf.keras.layers.Lambda(Func, name = 'Lambda_1')([en1,en2])
  
  def Func1(x):
      return (x[0]-x[1])
  Lambda_2 = tf.keras.layers.Lambda(Func1, name = 'Lambda_2')([en1,en2])
  
  concat = tf.keras.layers.Concatenate()([lstm1,lstm1avg,Lambda_1,Lambda_2,lstm2avg,lstm2])

  flat = Flatten()(concat)
  Dense1 = Dense(300,activation = 'relu')(flat)
  Drop1 = Dropout(0.1)(Dense1)
  Dense2 = Dense(300,activation = 'relu')(Drop1)
  Drop2 = Dropout(0.1)(Dense2)
  output = tf.keras.layers.Dense(3,activation='softmax')(Drop2)
  full_model = tf.keras.Model(inputs = [input1,input2], outputs=output)
  full_model.compile(optimizer='adam', loss='categorical_crossentropy', metrics = ['accuracy'])
  return full_model

from sklearn import metrics
if __name__ == "__main__":
  sen1_train,sen2_train,Ytrain,sen1_test,sen2_test,Ytest = preprocess('drive/My Drive/SNLI/snli_1.0_train.jsonl','drive/My Drive/SNLI/snli_1.0_test.jsonl')
  Xtrain1,Xtrain2,Xtest1,Xtest2,vocab_size,embedding_matrix = embedding(sen1_train,sen2_train,sen1_test,sen2_test)
  model = create_model(vocab_size,embedding_matrix)
  history = model.fit([Xtrain1,Xtrain2],Ytrain,batch_size=500,validation_split = 0.2,epochs=8)
  model.save('models/Deep_Learning_model1.h5')
  
